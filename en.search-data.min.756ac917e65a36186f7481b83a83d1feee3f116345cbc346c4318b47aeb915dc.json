[{"id":0,"href":"/iqa-management-hub/01-writing-system-tests/","title":"1. Writing system tests","section":"IQA Management Hub","content":" 1. Writing system tests # So here I am - I made a decision to make a rewrite of the service. Where do I start? Well, the number one thing I want to do is to try to follow good practices. I don\u0026rsquo;t want to just write this thing from scratch and swap them out in one go, possibly breaking tens of existing users with something I haven\u0026rsquo;t tested. So I need to first document how the existing service works. I will use system tests for that.\nWhat are system tests? # If you heard about the test pyramid you may be familiar with service or integration tests. The way I define system tests is an external testing process making calls to a locally deployed application and validating the general behavior.\nWhat this means is that the system test mostly doesn\u0026rsquo;t care about implementation details and focuses on externalities. For a web API that means most tests should be performable by making HTTP requests against the service. In my case because I need to document a bit deeper how the service behaves I will also be connecting to the database to inspect it, clean up state created with the tests, etc.\nSetup # I\u0026rsquo;ve created a new .NET 6 project with the XUnit template and added Xunit.DependencyInjection which allows me to use dependency injection, configuration files and advanced logging controls.\nI\u0026rsquo;ve also created a project for models and generated classes using Entity Framework Core dotnet tool. The app uses postgres so I installed Npgsql.EntityFrameworkCore.PostgreSQL. Then I ran dotnet ef dbcontext scaffold to set up the models. I like to keep models mostly pure, so all my EF configuration ends up in the DbContext class.\nFinally I needed some tools for making the HTTP requests and I opted for writing my own, specifically tailored to this app.\nHttpClient # I have read a lot in the past on how to use the HttpClient. The most recent advice says to use IHttpClientFactory from the Microsoft.Extensions.Http package. It allows us to use dependency injection to configure the client. And you can name the client to have multiple configurations.\nBut the main benefit is that the factory intelligently caches the HttpClientHandler instances which hold system resources. A big issue of manual handler management is port exhaustion when you create to many instances. It\u0026rsquo;s a general issue and I\u0026rsquo;ve seen systems die from this.\nIn .NET Core a new system of layers has been designed on top of the HttpClientHandler. There\u0026rsquo;s many small and reusable instances of DelegatingHandler which act very similarly to ASP.NET middleware. It can be used for injecting headers or otherwise modifying the request or the response.\nCookies # For accessing the management hub website you login with an email and a password and get a session cookie. Standard stuff. Took me 2 days to make it work.\nSo the first thing is cookies. As mentioned above, the HttpClientHandler is reused by multiple HttpClient instances to save on system resources. This means that the built in cookie management mechanism are out the window, because they\u0026rsquo;d be shared across multiple clients. We need the cookie store to be specific to a given test. Also we need to allow tests to run in parallel for fast CI times later on.\nSo I looked around and came up with this middleware (shout out to damianh\u0026rsquo;s gist which saved me from parsing cookies by hand)\n/// \u0026lt;summary\u0026gt; /// Message handler which substitutes the handling of cookies of the \u0026lt;see cref=\u0026#34;HttpClientHandler\u0026#34;/\u0026gt;. /// It allows to reuse a single instance of a underlying handler across multiple cookie sessions. /// \u0026lt;/summary\u0026gt; public class CookieSessionMessageHandler : DelegatingHandler { public static readonly HttpRequestOptionsKey\u0026lt;CookieContainer\u0026gt; CookieContainerOption = new(\u0026#34;CookieContainer\u0026#34;); protected override async Task\u0026lt;HttpResponseMessage\u0026gt; SendAsync( HttpRequestMessage request, CancellationToken cancellationToken) { if (!request.Options.TryGetValue(CookieContainerOption, out var cookieContainer)) return await base.SendAsync(request, cancellationToken); if (cookieContainer.Count \u0026gt; 0) request.Headers.Add(\u0026#34;Cookie\u0026#34;, cookieContainer.GetCookieHeader(request.RequestUri!)); var response = await base.SendAsync(request, cancellationToken); if (response.Headers.TryGetValues(\u0026#34;Set-Cookie\u0026#34;, out var cookieValues)) foreach (var cookieValue in cookieValues) { cookieContainer.SetCookies(request.RequestUri!, cookieValue); } return response; } } I\u0026rsquo;ve cleaned up the code a bit for this post to keep it shorter, but I also have some debug logs in there.\nWe can see I\u0026rsquo;m using the HttpRequestOptions collection to store the CookieContainer. This means I needed to write custom extensions over HttpClient for things like GetStringAsync(), because I wanted to build my own HttpRequestMessage and add the cookie container.\nThe middleware also works if we don\u0026rsquo;t care about cookies - this is generally a good practice - make your middleware opt-in rather than opt-out.\nFor sending the cookies we\u0026rsquo;re using a method of the CookieContainer called GetCookieHeader(url). For saving new cookies we\u0026rsquo;re using the SetCookies(url, cookieHeader) method. If you happen to have issues with it, checkout the helper class SetCookieHeaderValue, from Microsoft.Net.Http.Headers package, to parse the headers.\nSo with this cookie middleware I was able to log in, but afterwards something wasn\u0026rsquo;t working and I had to debug it.\nRedirects # The session cookie system of Rails works in a way that sends a new cookie with each request. I believe it\u0026rsquo;s meant to prevent an attacker from stealing a session in some way (see Rails guide on security).\nWith this new cookie middleware I was sending redirect requests with the same cookie as the original request.\nsequenceDiagram CookieMiddleware-\u003e\u003eHttpClientHandler: Headers[\"Cookie\"] HttpClientHandler-\u003e\u003eWebsite: HTTP request Website--\u003e\u003eHttpClientHandler: 302 Headers[\"Location\"] HttpClientHandler-\u003e\u003eWebsite: HTTP GET request to new location Website--\u003e\u003eHttpClientHandler: 200 OK HttpClientHandler--\u003e\u003eCookieMiddleware: Headers[\"Set-Cookie\"] And this wasn\u0026rsquo;t working, so I had to write my own redirect layer on top of it.\n/// \u0026lt;summary\u0026gt; /// Message handler which substitutes the handling of redirects of the \u0026lt;see cref=\u0026#34;HttpClientHandler\u0026#34;/\u0026gt;. /// We needed redirection layer on top of the custom cookie middleware. /// \u0026lt;/summary\u0026gt; public class FollowRedirectsMessageHandler : DelegatingHandler { protected override async Task\u0026lt;HttpResponseMessage\u0026gt; SendAsync( HttpRequestMessage request, CancellationToken cancellationToken) { var response = await base.SendAsync(request, cancellationToken); if (response.Headers.TryGetValues(\u0026#34;Location\u0026#34;, out var locations)) { var redirectRequest = new HttpRequestMessage(HttpMethod.Get, locations.First()); if (request.Options is IDictionary\u0026lt;string, object?\u0026gt; requestOptions \u0026amp;\u0026amp; redirectRequest.Options is IDictionary\u0026lt;string, object?\u0026gt; newOptions) foreach (var kvp in requestOptions) { newOptions.Add(kvp.Key, kvp.Value); } return await this.SendAsync(redirectRequest, cancellationToken); } return response; } } Basically whenever there\u0026rsquo;s a Location header present we make a new request there and copy all the request options. Note how I used base.SendAsync and this.SendAsync to go directly down the request pipeline or call this method recursively to allow for following multiple redirects.\nsequenceDiagram RequestMiddleware-\u003e\u003eCookieMiddleware: . CookieMiddleware-\u003e\u003eHttpClientHandler: Headers[\"Cookie\"] HttpClientHandler-\u003e\u003eWebsite: HTTP request Website--\u003e\u003eHttpClientHandler: 302 Headers[\"Location\"] HttpClientHandler--\u003e\u003eCookieMiddleware: Headers[\"Set-Cookie\"] CookieMiddleware--\u003e\u003eRequestMiddleware: . RequestMiddleware-\u003e\u003eCookieMiddleware: GET redirected CookieMiddleware-\u003e\u003eHttpClientHandler: Headers[\"Cookie\"] HttpClientHandler-\u003e\u003eWebsite: HTTP request Configuring the HttpClient # Finally we go to the Configure method to set up dependency injection.\nservices.AddTransient\u0026lt;FollowRedirectsMessageHandler\u0026gt;(); services.AddTransient\u0026lt;CookieSessionMessageHandler\u0026gt;(); services.AddHttpClient(RequestBuilder.HttpClientName) .ConfigurePrimaryHttpMessageHandler(() =\u0026gt; new HttpClientHandler { AllowAutoRedirect = false, UseCookies = false, }) // Ordering of the handlers is important, from top (outermost) to bottom .AddHttpMessageHandler\u0026lt;FollowRedirectsMessageHandler\u0026gt;() .AddHttpMessageHandler\u0026lt;CookieSessionMessageHandler\u0026gt;(); We disable redirects and cookies on the HttpClientHandler because we add middleware to handle it instead.\n"},{"id":1,"href":"/iqa-management-hub/","title":"IQA Management Hub","section":"Marian's Blog","content":" IQA Management Hub # You may not have heard about it, but there\u0026rsquo;s a sport called quadball, formerly known as quidditch. I discovered it when I was in highschool, got really into it. But obviously sport is not just the players. It\u0026rsquo;s referees, team managers, league organizers. So at some point I decided to volunteer for the IQA - International Quadball Association. And my favorite capacity of volunteering is as a software engineer.\nIQA doesn\u0026rsquo;t have a lot needs for a big team of programmers. They run a website with news blog posts and a service called Management Hub. It\u0026rsquo;s a single place for admins of National Governing Bodies (country members of IQA) to provide official statistics to the IQA and a referee hub for certifying referees.\nSo at the moment of writing I\u0026rsquo;m the one maintaining it.\nAnd as I set off in my role I decided I don\u0026rsquo;t want to do any rewrites, just keep the existing codebase alive. Easier said than done. It was written in ruby on rails and it\u0026rsquo;s cool. BUT I can\u0026rsquo;t spend the time to learn ruby in depth to migrate to a newer version where a lot of things will break. AND I like C# a lot. So I\u0026rsquo;m going to try to rewrite this site into ASP.NET Core and try to fix a lot of issues that piled up over time.\n"}]