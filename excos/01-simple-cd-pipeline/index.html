<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  1. Simple CI/CD pipeline
  #

Before I start writing code for a new project I want to set up a very simple pipeline for getting it deployed.
I decided to use Docker containers as means of packaging the app since they offer a lot of simplicity once built.
If I was using a cloud platform for running containers it would likely come with some deployment system and a GitHub integration.
But I want to keep this project fairly low cost for now. Instead of using a big cloud provider I&rsquo;m renting a small VPS for 8 euro a month."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://devblog.dziubiak.pl/excos/01-simple-cd-pipeline/"><meta property="og:site_name" content="Marian's Blog"><meta property="og:title" content="1. Simple CI/CD pipeline"><meta property="og:description" content="1. Simple CI/CD pipeline # Before I start writing code for a new project I want to set up a very simple pipeline for getting it deployed. I decided to use Docker containers as means of packaging the app since they offer a lot of simplicity once built. If I was using a cloud platform for running containers it would likely come with some deployment system and a GitHub integration. But I want to keep this project fairly low cost for now. Instead of using a big cloud provider Iâ€™m renting a small VPS for 8 euro a month."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="excos"><meta property="article:modified_time" content="2024-10-20T12:21:49+01:00"><meta property="og:image" content="https://devblog.dziubiak.pl/blog.jpg"><title>1. Simple CI/CD pipeline | Marian's Blog</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://devblog.dziubiak.pl/excos/01-simple-cd-pipeline/><link rel=stylesheet href=/book.min.2d7fec8e866046a7460a1cc86027535586803606a87c87da3098bcd8d5a2b62d.css integrity="sha256-LX/sjoZgRqdGChzIYCdTVYaANgaofIfaMJi82NWiti0=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.e220b5418b3fc5ddd487c3bb8dd43bba5ecd6366ca1bbaeacfb54fdb14948b16.js integrity="sha256-4iC1QYs/xd3Uh8O7jdQ7ul7NY2bKG7rqz7VP2xSUixY=" crossorigin=anonymous></script><script defer src=https://cloud.umami.is/script.js data-website-id=487bcc6b-5cf2-4079-af93-72592662cf29></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/manio.png alt=Logo class=book-icon><span>Marian's Blog</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/excos/>Excos</a><ul><li><a href=/excos/01-simple-cd-pipeline/ class=active>1. Simple CI/CD pipeline</a></li><li><a href=/excos/03-privacy-compliance/>3. Implementing privacy compliance</a></li></ul></li><li><a href=/iqa-management-hub/>IQA Management Hub</a><ul><li><a href=/iqa-management-hub/01-writing-system-tests/>1. Writing system tests</a></li></ul></li><li><a href=/stride/>Stride</a><ul><li><a href=/stride/01-nuget-plugins/>1. Using NuGet packages as plugins</a></li></ul></li><li><a href=/telemetry/>Telemetry</a><ul><li><a href=/telemetry/01-exporting-eventsource-locally/>1. Exporting EventSource logs to CSV</a></li></ul></li><li><a href=/web/>Web</a><ul><li><a href=/web/01-isolated-features/>1. Isolated web features within a single ASP.NET Core service</a></li><li><a href=/web/02-experimentation/>2. Short guide to experimentation</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>1. Simple CI/CD pipeline</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#preparing-the-image>Preparing the image</a></li><li><a href=#uploading-the-image>Uploading the image</a></li><li><a href=#running-containers-with-compose>Running containers with compose</a></li><li><a href=#restricting-access>Restricting access</a><ul><li><a href=#containers>Containers</a></li><li><a href=#leveraging-sudoers>Leveraging sudoers</a></li></ul></li><li><a href=#disk-space-cleanup>Disk space cleanup</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=1-simple-cicd-pipeline>1. Simple CI/CD pipeline
<a class=anchor href=#1-simple-cicd-pipeline>#</a></h1><p>Before I start writing code for a new project I want to set up a very simple pipeline for getting it deployed.
I decided to use Docker containers as means of packaging the app since they offer a lot of simplicity once built.
If I was using a cloud platform for running containers it would likely come with some deployment system and a GitHub integration.
But I want to keep this project fairly low cost for now. Instead of using a big cloud provider I&rsquo;m renting a small VPS for 8 euro a month.</p><p>A small server with a static IP address running docker.
A basic setup for starting out. I tried googling container orchestration and everything comes with a lot of upfront configuration.
Except <code>docker-compose</code> which has small enough footprint for my needs and I&rsquo;ve worked with it before enough to be able to set something up within an hour.
Docker commands can be executed over an SSH connection.</p><p>Another thing is dealing with docker images.
I could use a container registry for storing the images, but if I want to iterate quickly I may end up creating a lot of images.
Depending on the registry this comes with adequate costs, so I&rsquo;m thinking of using it only for releases (however that gets defined later) while managing the short term images directly on the target host.</p><h2 id=preparing-the-image>Preparing the image
<a class=anchor href=#preparing-the-image>#</a></h2><p>I&rsquo;m going to skip over the building process for now. The important part is that we end up with a tagged image on our build machine.
Ideally we want to assign a unique build number to the image each time we build the software.
Same build number should be available to the application within the image to be later used for telemetry.</p><p>We want to follow the
<a href=//semver.org>Semantic Versioning</a> and one of the options is doing something like <code>MAJOR.MINOR.PATCH-BUILD+SHA</code> for continuously building the image (e.g. in a PR or feature branch) and dropping the build info once the change is accepted (e.g. merged into main).
We can leverage something like
<a href=https://gitversion.net/>GitVersion</a> to automate the version calculation.</p><h2 id=uploading-the-image>Uploading the image
<a class=anchor href=#uploading-the-image>#</a></h2><p>In order to upload the image to the target host we will leverage the <code>docker save</code> and <code>docker load</code> commands.
They work with a tarball and need an extra program to compress the image in transit (e.g. <code>gzip</code>).
We will also leverage docker&rsquo;s integration with SSH.
The command will be as follows (
<a href=https://stackoverflow.com/a/62176367>ref</a>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker save &lt;image:tag&gt; | gzip | DOCKER_HOST<span style=color:#f92672>=</span>ssh://&lt;user&gt;@&lt;host&gt; docker load
</span></span></code></pre></div><p>In order for this to work the user has to have access to the docker socket.
However, having access to the docker socket means being able to ask docker engine to execute anything (as root).</p><h2 id=running-containers-with-compose>Running containers with compose
<a class=anchor href=#running-containers-with-compose>#</a></h2><p>We can leverage the <code>DOCKER_HOST</code> (or docker contexts) to remotely invoke the <code>docker compose</code> command and specify the configuration file with the <code>-f</code> parameter.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>scp docker-compose.yml &lt;user&gt;@&lt;host&gt;:&lt;path&gt;
</span></span><span style=display:flex><span>DOCKER_HOST<span style=color:#f92672>=</span>ssh://&lt;user&gt;@&lt;host&gt; docker compose up -d -f &lt;path&gt;
</span></span></code></pre></div><h2 id=restricting-access>Restricting access
<a class=anchor href=#restricting-access>#</a></h2><p>Docker engine is running under the root account which means it&rsquo;s able to do anything on the system.
In particular a user with docker access could run a container and mount the filesystem root of the host in the container.
There&rsquo;s really a lot of space for exploitation and the general advice is to only give access to trusted users.
However, since I&rsquo;m going to give the CI system (e.g. GitHub Actions) the SSH key to access my server, I want to ensure there&rsquo;s not too much an attacker could do should they obtain the secret key.</p><p>I&rsquo;ve been looking online and there&rsquo;s generally not much on this topic.
Majority of articles gives solid advice on how to isolate containers from one another or from the host.
Example lists:
<a href=https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Docker_Security_Cheat_Sheet.md>OWASP</a>,
<a href=https://medium.com/@SecurityArchitect/docker-security-settings-for-running-untrusted-trusted-containers-at-the-same-time-88c4ca012726>SecurityArchitect</a>.</p><p>From that second list I stumbled over this article on the use of
<a href=https://security.theodo.com/en/blog/security-docker-apparmor>AppArmor</a> which does mention you can apply a restrictive policy to the docker engine process as well (
<a href=https://github.com/moby/moby/blob/master/contrib/apparmor/template.go>template</a>).
I might need to learn a bit more about AppArmor as it&rsquo;s a solid security mechanism.</p><h3 id=containers>Containers
<a class=anchor href=#containers>#</a></h3><p>Another set of things we can do is modify the Docker daemon
<a href=https://docs.docker.com/reference/cli/dockerd/#daemon-configuration-file>configuration</a> to set some good defaults for the containers.</p><blockquote><p>Note that any docker configuration can be overridden when running a command and this does not constitute a security measure!</p></blockquote><ul><li><code>"userns-remap": "default"</code> - makes root user inside a container an unprivileged user when interacting with the host</li><li><code>"no-new-privileges": true</code> - prevent the container from gaining new privileges via setuid or setgid binaries</li><li><code>"icc": false</code> - disable inter-container connectivity over docker0 bridge network (requires creating custom networks)</li></ul><p>Additionally we can install
<a href=https://github.com/nestybox/sysbox>sysbox</a> and set the <code>runtimes</code> and <code>default-runtime</code> properties in the daemon config to use it.</p><h3 id=leveraging-sudoers>Leveraging sudoers
<a class=anchor href=#leveraging-sudoers>#</a></h3><p>Another option I was looking at was to skip giving a user direct access to the Docker socket and instead use a sudoers configuration to provide a set of elevated commands the user can execute.
This means that in the earlier examples instead of using SSH through the Docker client we will use SSH directly.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker save &lt;image:tag&gt; | gzip | ssh &lt;user&gt;@&lt;host&gt; sudo docker load
</span></span><span style=display:flex><span><span style=color:#75715e># and then</span>
</span></span><span style=display:flex><span>scp docker-compose.yml &lt;user&gt;@&lt;host&gt;:&lt;path&gt;
</span></span><span style=display:flex><span>ssh &lt;user&gt;@&lt;host&gt; sudo docker compose up -d -f &lt;path&gt;
</span></span></code></pre></div><p>For this we will create a new file under <code>/etc/sudoers.d/&lt;user></code> for our specific user:</p><pre tabindex=0><code>&lt;user&gt;  ALL=(root:docker) NOPASSWD: /usr/bin/docker load
&lt;user&gt;  ALL=(root:docker) NOPASSWD: /usr/bin/docker compose up -d -f *
</code></pre><p>This means the user can impersonate only the root user under the docker group, they will not be asked for password and they are allowed to execute the specified commands.
Note that <code>*</code> means any string, so the user can provide extra parameters to the compose command apart from just the file.
To restrict it further we should create a shell script which will validate arguments passed to it and apply them correctly.
The script could also check that the <code>docker-compose.yml</code> is not making the containers run with higher privileges than we want.</p><p>Afterwards verify the config with <code>sudo visudo -c</code> and you may have to run <code>sudo chmod 0440 /etc/sudoers.d/&lt;user></code> to restrict access to this file.</p><h4 id=example-limiting-script>Example limiting script
<a class=anchor href=#example-limiting-script>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo curl -L -o /usr/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
</span></span><span style=display:flex><span>sudo chmod +x /usr/bin/yq
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e># docker-compose-up.sh</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> <span style=color:#66d9ef>$(</span>yq <span style=color:#e6db74>&#39;.services.*.runtime&#39;</span> $1<span style=color:#66d9ef>)</span> !<span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;null&#34;</span> <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;The docker-compose file tries to override the default runtime&#34;</span> &gt;&amp;<span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  exit <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>docker compose -f $1 up -d
</span></span></code></pre></div><h2 id=disk-space-cleanup>Disk space cleanup
<a class=anchor href=#disk-space-cleanup>#</a></h2><p>As we are pushing images onto the server we need to be conscious of how much space they take.
You should strive for building small container images with the minimal set of required dependencies, but even then they can add up and clog up the disk.
Therefore you should look to clean up previous images after deployment.</p><p>The docker
<a href=https://docs.docker.com/engine/manage-resources/pruning/>prune</a> command can be used to delete unused resources.
If you&rsquo;re versioning the images such that they contain build number, rerunning CI on a previous commit will anyways create a new image so you can safely remove anything older.
But if you want to keep the last N images for easy rollback to a previous version:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker rmi <span style=color:#66d9ef>$(</span>docker images -q &lt;repository/image&gt; | tail -n +&lt;N+1&gt;<span style=color:#66d9ef>)</span>
</span></span></code></pre></div><p>The name passed in doesn&rsquo;t contain the tag, but starts with the repository (if not from Docker Hub).
The images command returns images in order, latest first.
The tail command prints lines starting from X if we pass <code>-n X</code>, so to skip N latest images we pass N+1.</p><h2 id=conclusion>Conclusion
<a class=anchor href=#conclusion>#</a></h2><p>There we have it - a simple CI/CD pipeline which pushes a container image directly into the target host and uses docker compose to instantiate, while keeping in mind the security aspect of allowing external access to your server.</p><p>Once I have this up and running on GitHub I will add here a link to the workflow definition.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><span class="flex align-center" title='Last modified by Marian Dziubiak | October 20, 2024'><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>Last modified October 20, 2024</span></span></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#preparing-the-image>Preparing the image</a></li><li><a href=#uploading-the-image>Uploading the image</a></li><li><a href=#running-containers-with-compose>Running containers with compose</a></li><li><a href=#restricting-access>Restricting access</a><ul><li><a href=#containers>Containers</a></li><li><a href=#leveraging-sudoers>Leveraging sudoers</a></li></ul></li><li><a href=#disk-space-cleanup>Disk space cleanup</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></aside></main></body></html>