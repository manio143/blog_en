<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="1. Exporting EventSource logs to CSV # Here&rsquo;s a scenario - you&rsquo;re building a service and you&rsquo;re emitting logs as you should be. But your service is configured to send those logs to a log collector. You don&rsquo;t have a lot of budget and you&rsquo;re using a log collector in production but locally you only write out to console (or Debug window in Visual Studio). Maybe you want to persist your logs over a few sessions, maybe you have an automated test environment which hosts your service without console output being saved anywhere."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="1. Exporting EventSource logs to CSV"><meta property="og:description" content="1. Exporting EventSource logs to CSV # Here&rsquo;s a scenario - you&rsquo;re building a service and you&rsquo;re emitting logs as you should be. But your service is configured to send those logs to a log collector. You don&rsquo;t have a lot of budget and you&rsquo;re using a log collector in production but locally you only write out to console (or Debug window in Visual Studio). Maybe you want to persist your logs over a few sessions, maybe you have an automated test environment which hosts your service without console output being saved anywhere."><meta property="og:type" content="article"><meta property="og:url" content="https://devblog.dziubiak.pl/telemetry/01-exporting-eventsource-locally/"><meta property="og:image" content="https://devblog.dziubiak.pl/blog.jpg"><meta property="article:section" content="telemetry"><meta property="article:modified_time" content="2023-05-12T15:49:29+01:00"><title>1. Exporting EventSource logs to CSV | Marian's Blog</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.78166b9d46e23e0ea915cb6887a30b633e7bc4fad10c8b6b9f6fa532271c19ba.js integrity="sha256-eBZrnUbiPg6pFctoh6MLYz57xPrRDItrn2+lMiccGbo=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/manio.png alt=Logo><span>Marian's Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/iqa-management-hub/>IQA Management Hub</a><ul><li><a href=/iqa-management-hub/01-writing-system-tests/>1. Writing system tests</a></li></ul></li><li><a href=/telemetry/>Telemetry</a><ul><li><a href=/telemetry/01-exporting-eventsource-locally/ class=active>1. Exporting EventSource logs to CSV</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>1. Exporting EventSource logs to CSV</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#eventsource>EventSource?</a></li><li><a href=#perfview-library>PerfView library</a></li><li><a href=#building-my-tool>Building my tool</a></li><li><a href=#graceful-stopping>Graceful stopping</a></li></ul></nav></aside></header><article class=markdown><h1 id=1-exporting-eventsource-logs-to-csv>1. Exporting EventSource logs to CSV
<a class=anchor href=#1-exporting-eventsource-logs-to-csv>#</a></h1><p>Here&rsquo;s a scenario - you&rsquo;re building a service and you&rsquo;re emitting logs as you should be.
But your service is configured to send those logs to a log collector.
You don&rsquo;t have a lot of budget and you&rsquo;re using a log collector in production but locally you only write out to console (or Debug window in Visual Studio).
Maybe you want to persist your logs over a few sessions, maybe you have an automated test environment which hosts your service without console output being saved anywhere.
Sure you might implement a file sink for your logs.</p><p>Or you might decide to capture the data from the EventSource your service might be already using.</p><h2 id=eventsource>EventSource?
<a class=anchor href=#eventsource>#</a></h2><p>This post is for .NET devs. What is an EventSource?
It&rsquo;s an old API designed in .NET Framework to pipe events into the ETW (Event Tracing for Windows) system.
It has been revamped in .NET Core to be multi-platform and it&rsquo;s the provider of data into <code>dotnet-trace</code> tool.
Many internal components emit EventSource events (like GC for example).</p><p>And some logging libraries do as well. For example <code>Microsoft.Extensions.Logging</code> is able to export logs to an event source.
See
<a href=https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Logging.EventSource/src/EventSourceLoggerFactoryExtensions.cs>AddEventSourceLogger</a> method.
It&rsquo;s on by default with the default Host builder.</p><p>References:</p><ul><li><a href=https://learn.microsoft.com/en-us/dotnet/core/diagnostics/eventsource-getting-started>EventSource - Getting started</a></li><li><a href=https://learn.microsoft.com/en-us/dotnet/core/extensions/logging-providers#event-source>EventSource provider</a></li></ul><h2 id=perfview-library>PerfView library
<a class=anchor href=#perfview-library>#</a></h2><p>So you can capture events using <code>dotnet-trace</code> and view them in standalone
<a href=https://github.com/microsoft/perfview/releases>PerfView</a> application.
It&rsquo;s powerful but not the most comfortable way of dealing with text logs.
Not that CSV is much better, but maybe a little.</p><p>PerfView ships either as a GUI app or as a NuGet package <code>Microsoft.Diagnostics.Tracing.TraceEvent</code>.
You can use the library to either:</p><ul><li>open a file produced by <code>dotnet-trace</code> - using <code>new EventPipeEventSource(inputFileName)</code>.</li><li>listen to any events from a provider - using <code>new TraceEventSession(sessionName)</code> with <code>session.EnableProvider(providerName)</code>.</li></ul><p>I opted for the second one, because it allows us to start capturing events as soon as the application starts
and it can simultaneously process events from multiple processes.</p><p>For example to listen to events from the <code>Microsoft-Extensions-Logging</code> EventSource
(
<a href=https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Logging.EventSource/src/LoggingEventSource.cs>source</a>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>using</span> (TraceEventSession session = <span style=color:#66d9ef>new</span> TraceEventSession(<span style=color:#e6db74>&#34;MyTraceSession&#34;</span>))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Enable the ETW session to listen for events from an EventSource</span>
</span></span><span style=display:flex><span>    session.EnableProvider(<span style=color:#e6db74>&#34;Microsoft-Extensions-Logging&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// filter events to only a specific type and process with callback</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// we might only listen for MessageJson events for example</span>
</span></span><span style=display:flex><span>    session.Source.Dynamic.AddCallbackForProviderEvents(
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>string</span> providerName, <span style=color:#66d9ef>string</span> eventName) =&gt;
</span></span><span style=display:flex><span>            providerName == <span style=color:#e6db74>&#34;Microsoft-Extensions-Logging&#34;</span> &amp;&amp; eventName == <span style=color:#e6db74>&#34;MessageJson&#34;</span>
</span></span><span style=display:flex><span>                ? EventFilterResponse.AcceptEvent
</span></span><span style=display:flex><span>                : EventFilterResponse.RejectEvent;,
</span></span><span style=display:flex><span>        (TraceEvent data) =&gt; {<span style=color:#75715e>/* do stuff with the event */</span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    session.Source.Process(); <span style=color:#75715e>// Listen to events and invoke callback for events in the source</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>AddCallbackForProviderEvents</code> takes two functions:</p><ul><li>event filter - which allows you to specify which events your processor supports,</li><li>event callback - which allows you to process events one by one.</li></ul><p>So for me the callback read data from <code>TraceEvent</code> object and emitted them to CSV files.
The event object contains info about which process emitted it and the payload with data.</p><p>You can either process event with typed handlers (which I didn&rsquo;t manage to do because you need to generate a C# class from ETW manifest)
or a dynamic handler. In this case I&rsquo;m reading dynamic properties from payload like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>TimeStamp = data.TimeStamp.ToString(<span style=color:#e6db74>&#34;s&#34;</span>),
</span></span><span style=display:flex><span>ThreadId = data.ThreadID.ToString(<span style=color:#e6db74>&#34;X&#34;</span>),
</span></span><span style=display:flex><span>TagId = <span style=color:#66d9ef>new</span> EventId((<span style=color:#66d9ef>int</span>)data.PayloadByName(<span style=color:#e6db74>&#34;EventId&#34;</span>)).ToTagId(),
</span></span><span style=display:flex><span>Level = ((LogLevel)data.PayloadByName(<span style=color:#e6db74>&#34;Level&#34;</span>)).ToString(),
</span></span><span style=display:flex><span>LoggerName = data.PayloadStringByName(<span style=color:#e6db74>&#34;LoggerName&#34;</span>),
</span></span><span style=display:flex><span>Message = data.PayloadStringByName(<span style=color:#e6db74>&#34;FormattedMessage&#34;</span>),
</span></span><span style=display:flex><span>ExceptionDetails = data.PayloadStringByName(<span style=color:#e6db74>&#34;ExceptionJson&#34;</span>),
</span></span></code></pre></div><p>If your event source emits structures, you can do this <code>(IDictionary&lt;string, object>)data.PayloadByName("ComplexColumn")</code>.</p><p>So I wrote a little bit more code to use the <code>CsvHelper</code> library and write out the CSV files.
I&rsquo;m not gonna post all of the code but it goes a little bit like this:</p><p>On each event:</p><ol><li>Get CSV file name (process name + PID),</li><li>Create (or get from cache) an instance of the <code>CsvWriter</code> for the file name:<ul><li>if the file didn&rsquo;t exist we create it and write the header, otherwise just append to it</li></ul></li><li>Extract a row of data from event,</li><li>Write a row to the CSV file.</li></ol><p>References:</p><ul><li><a href=https://learn.microsoft.com/en-us/shows/perfview-tutorial/>PerfView application tutorials</a></li><li><a href=https://github.com/microsoft/perfview/blob/main/documentation/TraceEvent/TraceEventLibrary.md>The Microsoft.Diagnostics.Tracing.TraceEvent Library</a></li><li><a href=https://github.com/microsoft/perfview/blob/main/documentation/TraceEvent/TraceEventProgrammersGuide.md>The TraceEvent Library Programmers Guide</a></li><li><a href=https://learn.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-trace>dotnet-trace tool</a></li><li><a href=https://joshclose.github.io/CsvHelper/>CsvHelper website</a></li><li><a href=https://superuser.com/questions/7169/querying-a-csv-file>Ways to query a CSV file with SQL</a></li></ul><h2 id=building-my-tool>Building my tool
<a class=anchor href=#building-my-tool>#</a></h2><p>I decided to build my tool (which was like 4 C# files) into a single standalone executable,
because I needed to deploy it into our test environment to collect logs from automated testing.</p><p>An alternative is to create your tool in a portable way as a
<a href=https://learn.microsoft.com/en-us/dotnet/core/tools/global-tools>dotnet tool</a>
but to use it the machine needs to have .NET SDK installed.</p><p>So here&rsquo;s my configuration to publish a single file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;DebugType&gt;</span>Embedded<span style=color:#f92672>&lt;/DebugType&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;SelfContained&gt;</span>true<span style=color:#f92672>&lt;/SelfContained&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;PublishSingleFile&gt;</span>true<span style=color:#f92672>&lt;/PublishSingleFile&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;GenerateDocumentationFile&gt;</span>false<span style=color:#f92672>&lt;/GenerateDocumentationFile&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;EnableCompressionInSingleFile&gt;</span>true<span style=color:#f92672>&lt;/EnableCompressionInSingleFile&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;IncludeAllContentForSelfExtract&gt;</span>true<span style=color:#f92672>&lt;/IncludeAllContentForSelfExtract&gt;</span>
</span></span></code></pre></div><p>I was able to call <code>dotnet publish</code> and get a nice executable.</p><p>But I wanted to package it into a NuGet package which would contain just a <code>tools</code> folder with the executable.
This took me two days to figure out fully.</p><p>First, we want to enabling packing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;IsPackable&gt;</span>true<span style=color:#f92672>&lt;/IsPackable&gt;</span>
</span></span></code></pre></div><p>Next, since we don&rsquo;t want to include build outputs, but instead publish output, we will disable that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;!-- don&#39;t include DLL files produced by this project because we&#39;re manually adding publish output --&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;IncludeBuildOutput&gt;</span>false<span style=color:#f92672>&lt;/IncludeBuildOutput&gt;</span>
</span></span></code></pre></div><p>Now, I&rsquo;m going to add two targets - first one triggers the publish action after building and before packing,
second one includes the publish output in the package:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;Target</span> <span style=color:#a6e22e>Name=</span><span style=color:#e6db74>&#34;PublishBeforePack&#34;</span> <span style=color:#a6e22e>BeforeTargets=</span><span style=color:#e6db74>&#34;GenerateNuspec&#34;</span> <span style=color:#a6e22e>AfterTargets=</span><span style=color:#e6db74>&#34;Build&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;CallTarget</span> <span style=color:#a6e22e>Targets=</span><span style=color:#e6db74>&#34;Publish&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/Target&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;Target</span> <span style=color:#a6e22e>Name=</span><span style=color:#e6db74>&#34;UpdatePackOutput&#34;</span> <span style=color:#a6e22e>BeforeTargets=</span><span style=color:#e6db74>&#34;GenerateNuspec&#34;</span> <span style=color:#a6e22e>AfterTargets=</span><span style=color:#e6db74>&#34;Publish&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;ItemGroup&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;_PackageFiles</span> <span style=color:#a6e22e>Include=</span><span style=color:#e6db74>&#34;@(PublishItemsOutputGroupOutputs)&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;FinalOutputPath&gt;</span>%(PublishItemsOutputGroupOutputs.OutputPath)<span style=color:#f92672>&lt;/FinalOutputPath&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;PackagePath&gt;</span>tools<span style=color:#f92672>&lt;/PackagePath&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/_PackageFiles&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/ItemGroup&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/Target&gt;</span>
</span></span></code></pre></div><p>Finally, since the package has just a tool, it doesn&rsquo;t need any dependencies.
We can read online that property <code>PrivateAssets="all"</code> removes the dependency from nuspec.
But it also removes it from publish. After a while I found some issue on GitHub that mentioned
there&rsquo;s another property called <code>Publish</code> and setting it to true preserves the desired behavior for publishing.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;ItemGroup&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;PackageReference</span> <span style=color:#a6e22e>Include=</span><span style=color:#e6db74>&#34;CsvHelper&#34;</span> <span style=color:#a6e22e>Publish=</span><span style=color:#e6db74>&#34;True&#34;</span> <span style=color:#a6e22e>PrivateAssets=</span><span style=color:#e6db74>&#34;all&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;PackageReference</span> <span style=color:#a6e22e>Include=</span><span style=color:#e6db74>&#34;Microsoft.Diagnostics.Tracing.TraceEvent&#34;</span> <span style=color:#a6e22e>Publish=</span><span style=color:#e6db74>&#34;True&#34;</span> <span style=color:#a6e22e>PrivateAssets=</span><span style=color:#e6db74>&#34;all&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/ItemGroup&gt;</span>
</span></span></code></pre></div><p>But now that we&rsquo;ve gotten rid of library dependencies we need to do remove the framework dependency as well:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;!-- suppress framework dependency when there&#39;s no library dependencies due to PrivateAssets=all --&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;SuppressDependenciesWhenPacking&gt;</span>true<span style=color:#f92672>&lt;/SuppressDependenciesWhenPacking&gt;</span>
</span></span></code></pre></div><p>That&rsquo;s it. Well, there&rsquo;s one thing you need to do if you&rsquo;re still getting errors -
disable <code>IncludeSymbols</code> property which would generate the <code>snupkg</code> file.</p><p>With the package published to a NuGet source, you can use the following to extract the tool to
a projects output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;ItemGroup&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;PackageReference</span> <span style=color:#a6e22e>Include=</span><span style=color:#e6db74>&#34;LocalLogsExport&#34;</span> <span style=color:#a6e22e>Version=</span><span style=color:#e6db74>&#34;1.0.0&#34;</span> <span style=color:#a6e22e>ExcludeAssets=</span><span style=color:#e6db74>&#34;all&#34;</span> <span style=color:#a6e22e>GeneratePathProperty=</span><span style=color:#e6db74>&#34;true&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;None</span> <span style=color:#a6e22e>Include=</span><span style=color:#e6db74>&#34;$(PkgLocalLogsExport)\tools\*.exe&#34;</span> <span style=color:#a6e22e>CopyToOutputDirectory=</span><span style=color:#e6db74>&#34;PreserveNewest&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/ItemGroup&gt;</span>
</span></span></code></pre></div><p>References:</p><ul><li><a href=https://learn.microsoft.com/en-us/dotnet/core/tools/global-tools-how-to-create>Create dotnet tool</a></li><li><a href=https://learn.microsoft.com/en-us/dotnet/core/deploying/single-file/overview>Publish single file</a></li><li><a href=https://msbuildlog.com/>MSBuild debugging tool</a><ul><li>this is a life saver</li></ul></li><li><a href="https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets?view=vs-2022">MSBuild targets documentation</a></li><li><a href="https://learn.microsoft.com/en-us/visualstudio/msbuild/calltarget-task?view=vs-2022">CallTarget task documentation</a></li><li><a href=https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files>PackageReference documentation</a></li><li><a href=https://learn.microsoft.com/en-us/nuget/reference/nuspec>Nuspec documentation</a><ul><li>I was inspecting the nuspec generate in the obj folder</li></ul></li><li><a href=https://github.com/NuGet/Home/issues/5132>Suppress the &lt;dependencies> element when packing a project #5132</a></li><li><a href=https://github.com/NuGet/Home/issues/10372>NU5017 reported for symbol packages without clarifying this #10372</a><ul><li>that was the issue bugging me a long time</li></ul></li></ul><h2 id=graceful-stopping>Graceful stopping
<a class=anchor href=#graceful-stopping>#</a></h2><p>The way I wrote the tool the CSV file wasn&rsquo;t being flushed on each event.
So if you killed it, you&rsquo;d loose some rows only collected in memory.
Instead I subscribed to the console interrupt event to try to enable disposal of the CSV writer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> ConfigureProcesTermination(TraceEventSession session)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Console.CancelKeyPress += (_, args) =&gt;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        args.Cancel = <span style=color:#66d9ef>true</span>; <span style=color:#75715e>// prevent process from being terminated before cleanup</span>
</span></span><span style=display:flex><span>        session.Source.StopProcessing(); <span style=color:#75715e>// allow call to session.Source.Process() to return</span>
</span></span><span style=display:flex><span>                                         <span style=color:#75715e>// and nicely exit the using block</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// if we are being stopped more forcefully let&#39;s try to at least clean up the session from the system</span>
</span></span><span style=display:flex><span>    AppDomain.CurrentDomain.ProcessExit += (_, _) =&gt; session.Stop(noThrow: <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And then I was automating execution of my tool with Powershell and had to write this
monstrosity to gracefully stop the process:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#75715e># Stop trace capture gracefully (so that any buffers are flushed to disk) by sending it a CTRL+C signal</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Apparently there&#39;s no native way to do it in Powershell, so we&#39;re calling a kernel function</span>
</span></span><span style=display:flex><span><span style=color:#75715e># see https://stackoverflow.com/a/64930077</span>
</span></span><span style=display:flex><span><span style=color:#75715e># The FreeConsole and AttachConsole isolates the process from the current Powershell process (otherwise the Ctrl+C kills the script itself as well)</span>
</span></span><span style=display:flex><span>$MemberDefinition = <span style=color:#e6db74>&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    [DllImport(&#34;kernel32.dll&#34;)]public static extern bool FreeConsole();
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    [DllImport(&#34;kernel32.dll&#34;)]public static extern bool AttachConsole(uint p);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    [DllImport(&#34;kernel32.dll&#34;)]public static extern bool GenerateConsoleCtrlEvent(uint e, uint p);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    public static void SendCtrlC(uint p) {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        FreeConsole();
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        if (AttachConsole(p)) {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            GenerateConsoleCtrlEvent(0, p);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            FreeConsole();
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        AttachConsole(uint.MaxValue);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }&#39;</span>
</span></span><span style=display:flex><span>Add-Type -Name <span style=color:#e6db74>&#39;Console&#39;</span> -Namespace <span style=color:#e6db74>&#39;Process&#39;</span> -MemberDefinition $MemberDefinition
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$(Get-Process -Name <span style=color:#e6db74>&#39;LocalLogsExport&#39;</span>).Id | <span style=color:#66d9ef>foreach</span> { [<span style=color:#66d9ef>Process.Console</span>]::SendCtrlC($_) }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Wait-Process -Name <span style=color:#e6db74>&#39;LocalLogsExport&#39;</span> -Timeout <span style=color:#ae81ff>30</span> -ErrorAction Ignore
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><span class="flex align-center" title='Last modified by Marian Dziubiak | May 12, 2023'><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>Last modified May 12, 2023</span></span></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#eventsource>EventSource?</a></li><li><a href=#perfview-library>PerfView library</a></li><li><a href=#building-my-tool>Building my tool</a></li><li><a href=#graceful-stopping>Graceful stopping</a></li></ul></nav></div></aside></main></body></html>