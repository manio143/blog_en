<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Marian's Blog</title><link>https://devblog.dziubiak.pl/</link><description>Recent content on Marian's Blog</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://devblog.dziubiak.pl/index.xml" rel="self" type="application/rss+xml"/><item><title>1. Exporting EventSource logs to CSV</title><link>https://devblog.dziubiak.pl/telemetry/01-exporting-eventsource-locally/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://devblog.dziubiak.pl/telemetry/01-exporting-eventsource-locally/</guid><description>&lt;h1 id="1-exporting-eventsource-logs-to-csv">
 1. Exporting EventSource logs to CSV
 &lt;a class="anchor" href="#1-exporting-eventsource-logs-to-csv">#&lt;/a>
&lt;/h1>
&lt;p>Here&amp;rsquo;s a scenario - you&amp;rsquo;re building a service and you&amp;rsquo;re emitting logs as you should be.
But your service is configured to send those logs to a log collector.
You don&amp;rsquo;t have a lot of budget and you&amp;rsquo;re using a log collector in production but locally you only write out to console (or Debug window in Visual Studio).
Maybe you want to persist your logs over a few sessions, maybe you have an automated test environment which hosts your service without console output being saved anywhere.
Sure you might implement a file sink for your logs.&lt;/p></description></item><item><title>1. Isolated web features within a single ASP.NET Core service</title><link>https://devblog.dziubiak.pl/web/01-isolated-features/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://devblog.dziubiak.pl/web/01-isolated-features/</guid><description>&lt;h1 id="1-isolated-web-features-within-a-single-aspnet-core-service">
 1. Isolated web features within a single ASP.NET Core service
 &lt;a class="anchor" href="#1-isolated-web-features-within-a-single-aspnet-core-service">#&lt;/a>
&lt;/h1>
&lt;p>We&amp;rsquo;ve been discussion recently at work how we can increase our velocity for the team. I went to think and saw that a lot of new projects have a high upfront cost when it comes to provisioning the resources, setting up the build and deployment pipelines, etc. This is fine for longer running projects but would be delaying quick experiments much more than it should.&lt;/p></description></item><item><title>1. Simple CI/CD pipeline</title><link>https://devblog.dziubiak.pl/excos/01-simple-cd-pipeline/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://devblog.dziubiak.pl/excos/01-simple-cd-pipeline/</guid><description>&lt;h1 id="1-simple-cicd-pipeline">
 1. Simple CI/CD pipeline
 &lt;a class="anchor" href="#1-simple-cicd-pipeline">#&lt;/a>
&lt;/h1>
&lt;p>Before I start writing code for a new project I want to set up a very simple pipeline for getting it deployed.
I decided to use Docker containers as means of packaging the app since they offer a lot of simplicity once built.
If I was using a cloud platform for running containers it would likely come with some deployment system and a GitHub integration.
But I want to keep this project fairly low cost for now. Instead of using a big cloud provider I&amp;rsquo;m renting a small VPS for 8 euro a month.&lt;/p></description></item><item><title>1. Using NuGet packages as plugins</title><link>https://devblog.dziubiak.pl/stride/01-nuget-plugins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://devblog.dziubiak.pl/stride/01-nuget-plugins/</guid><description>&lt;h1 id="1-using-nuget-packages-as-plugins">
 1. Using NuGet packages as plugins
 &lt;a class="anchor" href="#1-using-nuget-packages-as-plugins">#&lt;/a>
&lt;/h1>
&lt;p>This post will be describing my journey to get a sensible plugin orchestration and delivery mechanism in place for the Stride game engine.
My main goal is to use NuGet architecture as much as possible and deliver a user experience that doesn&amp;rsquo;t require you to be a genius, nor has you copy-pasting things around too much. And because plugins are only meant for build time, and may target something else than your game, they cannot be directly referenced the usual way.&lt;/p></description></item><item><title>1. Writing system tests</title><link>https://devblog.dziubiak.pl/iqa-management-hub/01-writing-system-tests/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://devblog.dziubiak.pl/iqa-management-hub/01-writing-system-tests/</guid><description>&lt;h1 id="1-writing-system-tests">
 1. Writing system tests
 &lt;a class="anchor" href="#1-writing-system-tests">#&lt;/a>
&lt;/h1>
&lt;p>So here I am - I made a decision to make a rewrite of the service.
Where do I start? Well, the number one thing I want to do is to try to follow good practices.
I don&amp;rsquo;t want to just write this thing from scratch and swap them out in one go, possibly breaking tens of existing users with something I haven&amp;rsquo;t tested.
So I need to first document how the existing service works.
I will use system tests for that.&lt;/p></description></item><item><title>2. Short guide to experimentation</title><link>https://devblog.dziubiak.pl/web/02-experimentation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://devblog.dziubiak.pl/web/02-experimentation/</guid><description>&lt;h1 id="2-short-guide-to-experimentation">
 2. Short guide to experimentation
 &lt;a class="anchor" href="#2-short-guide-to-experimentation">#&lt;/a>
&lt;/h1>
&lt;p>Recently I&amp;rsquo;ve been involved in running an experiment at work and decided to dive a bit deeper into all the different parts of how to get it set up. You can find a lot of articles online which talk very vaguely about how to run an experiment. This post is meant to be a cheat sheet of sorts to give you a step by step of what is needed, but at the same time it won&amp;rsquo;t cover the topic very in depth. For the coding and instrumentation part I will focus on .NET as it&amp;rsquo;s my preferred tech stack but with a little bit of research you should have no problem finding the libraries for your preferred stack.&lt;/p></description></item><item><title>3. Implementing privacy compliance</title><link>https://devblog.dziubiak.pl/excos/03-privacy-compliance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://devblog.dziubiak.pl/excos/03-privacy-compliance/</guid><description>&lt;h1 id="3-implementing-privacy-compliance">
 3. Implementing privacy compliance
 &lt;a class="anchor" href="#3-implementing-privacy-compliance">#&lt;/a>
&lt;/h1>
&lt;p>In the modern internet everyone and their mother is collecting data about users.
And to be fair, I also want to collect some for legitimate reasons - making a better product and a better experience to my users.
But because there&amp;rsquo;s a lot of nefarious actors out there we now have regulations in place that explicitly require services to provide users with more control over their data.&lt;/p></description></item></channel></rss>